---
layout: post
title:  "Created a REST API with Spring Boot"
description: Quest of a developer, blog, docker, embedded jetty, h2 database, postgres database, cloudhero
date:   2016-11-28 19:18:09 +0200
commentIssueId: 6
published: true
---

Dear readers,

In this blog I will create a Spring Boot application which contains the REST-API for the "metjekindnaarbuiten" app. The Spring Boot application will use [Embedded Jetty](https://www.eclipse.org/jetty/documentation/9.4.x/embedding-jetty.html) as Java HTTP (Web) Server. As database [H2](http://www.h2database.com) will be used for local development, for the production environment [PostgreSQL](https://www.postgresql.org) will be used. Furthermore I will use [Spring Tools Suite](https://spring.io/tools) (STS) as IDE.

I've used these websites as input for creating my own Spring Boot application:

* <https://spring.io/guides/gs/spring-boot-docker>
* <https://www.3pillarglobal.com/insights/building-a-microservice-architecture-with-spring-boot-and-docker-part-i>
* <https://spring.io/guides/gs/accessing-data-jpa>
* <https://spring.io/guides/gs/gradle>

<br>
A few specifics on which I want to draw your attention to:

* I've used [Gradle](https://gradle.org) as a building tool.
* I've used JCenter instead of Maven Central. 
* I've switched from Embedded Tomcat to an Embedded Jetty implementation by adding these lines to my build.gradle file: ```compile.exclude module: "spring-boot-starter-tomcat"``` and ```compile("org.springframework.boot:spring-boot-starter-jetty")```. See this [link](http://docs.spring.io/spring-boot/docs/current/reference/html/howto-embedded-servlet-containers.html) for more information.
* **TIP**: This website <http://start.spring.io> provides a web-based quickstart generator for Spring projects.
* I've installed the [Buildship](https://projects.eclipse.org/projects/tools.buildship) extension for Gradle support in STS. However it does not seem to provide Gradle file syntax highlighting, formatting and completion. I've solved this problem by installing the [Groovy-Eclipse](https://github.com/groovy/groovy-eclipse/wiki) plugin.
* I've made my REST-API [CORS](https://www.w3.org/TR/cors) aware on global level. See <https://spring.io/guides/gs/rest-service-cors> for more information.
* My docker image extends the official java:8 image. The docker image can be created by running the ```buildDocker``` Gradle task.
* I've created a Docker Compose file (see the [docker-compose.yml](https://github.com/marinusgeuze/metjekindnaarbuiten/blob/master/backend/springboot/src/main/docker/docker-compose.yml) file) which orchestrates the multi-container "metjekindnaarbuiten" solution. In my case the Spring Boot application and the PostgreSQL database. 
* I've used the Automatic Restart and Live Reload capability of the Spring Boot Tools by adding the ```org.springframework.boot:spring-boot-devtools``` dependency and the LiveReload extension in Chrome. See this [link](https://spring.io/blog/2015/06/17/devtools-in-spring-boot-1-3) for more information. However this setup does not work because when I run the ```bootRun``` Gradle task from STS or the command prompt the application is started (and available on <http://localhost:8080>) but the launch of the task never finishes and never passes the 70% mark. This prevents the Automatic Restart feature. I've created [this post](http://stackoverflow.com/questions/40852362/why-does-the-bootrun-task-of-my-spring-boot-application-not-run-completely-in-gr) to get some support. 

<br>
The source of this project can be found [here](https://github.com/marinusgeuze/metjekindnaarbuiten/tree/master/backend/springboot). There are multiple ways to launch the application:

* Execute this commando if you want to run the application without docker: 
   1. ```gradlew bootRun``` or ```gradlew build && java -jar build/libs/metjekindnaarbuiten-spring-boot-docker-0.1.0.jar``` (the second option is the so called fat jar solution with embedded Jetty)
   2. Start <http://localhost:8080>
    
      * **NOTE**: For now you have to remove the application.properties file and comment out the ```org.postgresql:postgresql``` dependency and uncomment the ```com.h2database:h2``` dependency if you want to use the in-memory H2 database.
      * **TIP**: When using the H2 database a H2 Admin console is automatically available when you add the ```org.springframework.boot:spring-boot-devtools``` dependency. The url is <http://localhost:8080/h2-console>. Use ```jdbc:h2:mem:testdb``` as JDBC url.

<!-- enforce space -->

* Execute these commands if you want to run the application and [PostgreSQL database](https://hub.docker.com/_/postgres) with Docker: 
    1. ```gradlew build buildDocker```
    2. ```docker run -p 5432:5432 --name metjekindnaarbuitendb -e POSTGRES_PASSWORD=changethispassword -d postgres```
    3. ```docker run -p 80:8080 --name metjekindnaarbuiten --link metjekindnaarbuitendb:postgres -d marinusgeuze/metjekindnaarbuiten-spring-boot-docker```
    4. Start <http://localhost:80>

<!-- enforce space -->

* Execute these commands if you want to run the application and PostgreSQL database with Docker Compose: 
    1. ```gradlew build buildDocker```
    2. ```src\main\docker\docker-compose up```

<!-- enforce space -->

* Execute these commands if you want to run the application and PostgreSQL database with Docker Compose by a free Docker Cloud provider called CloudHero. This setup is however cumbersome because CloudHero does not support Windows. 
    1. Create account by <https://cloudhero.io>
    2. ```gradlew build buildDocker```
    3. 	```docker run -it centos:latest /bin/bash```
	4. **[execute only this command in an other command prompt]** 
	   ```docker cp C:\git\metjekindnaarbuiten\backend\sprintboot\src\main\docker\docker-compose.yml <container id centos image>:.```
	5. ```cd /```
	6. ```yum update```
	7. 
	```tee /etc/yum.repos.d/docker.repo <<-'EOF'
	[dockerrepo]
	name=Docker Repository
	baseurl=https://yum.dockerproject.org/repo/main/centos/7/
	enabled=1
	gpgcheck=1
	gpgkey=https://yum.dockerproject.org/gpg
	EOF```

	8. ```yum install docker-engine```
	9. ```eval $(curl -s https://portal.cloudhero.io/bootstrap/<your id>/script | sh)```
    10. ```curl -L https://github.com/docker/compose/releases/download/1.9.0/docker-compose-`uname -s`-`uname -m` > /usr/local/bin/docker-compose```
    11. ```chmod +x /usr/local/bin/docker-compose```
	12. ```docker-compose up```
	13. Start <http://swarm_yourid.cloudout.co>. In my case <http://swarm2089.cloudout.co>.

<br>

I realize that I have to improve this setup. My goal is to have a fully automated Continuous Integration and Deployment pipeline. Future will tell if I will reach this goal.

**Reminder:** My goal is to learn therefore feedback, comments and questions about this blog or related code are very welcome.

Happy coding,

Marinus